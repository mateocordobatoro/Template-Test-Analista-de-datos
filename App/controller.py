# -*- coding: utf-8 -*-
"""DataAnlayst.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WXR1aeRWYNGHEzOr6CQBYuzM0jI-Od5W
"""

# librerias
import csv
import re
from datetime import datetime
from tabulate import tabulate
from collections import Counter

from google.colab import files

uploaded = files.upload()

from google.colab import drive
drive.mount('/content/drive')

# Asegúrate de usar la ruta correcta al archivo, dependiendo de dónde lo hayas cargado.
file1 = 'small-jobs.csv'  # O la ruta completa si está en Drive

jobs = []
# Leer el archivo CSV línea por línea
with open(file1, mode='r', encoding='utf-8') as archivo:
    # Omitir los encabezados leyendo la primera línea antes del bucle
    encabezados = next(archivo)
    # Leer cada línea subsiguiente
    for linea in archivo:
        # Agregar la línea (sin el salto de línea final) a la lista 'jobs'
        jobs.append(linea.strip())

"""Al completar la carga de datos de las ofertas de trabajo (jobs-utf8.csv) se debe reportar los siguiente:


*  El total de ofertas de trabajo publicadas cargadas.
*  La información de las tres primeras y tres últimas ofertas de trabajo publicadas ordenadas por la fecha de publicación.
Cada elemento debe contener los siguientes detalles:
  * Fecha de publicación.
  * Título de la oferta
  * Nombre de la empresa que publica
  * Nivel de experticia de la oferta
  * País de la oferta
  * Ciudad de la oferta


"""

# Asegúrate de usar la ruta correcta al archivo, dependiendo de dónde lo hayas cargado.
file2 = 'small-skills.csv'  # O la ruta completa si está en Drive

skills = []
# Leer el archivo CSV línea por línea
with open(file2, mode='r', encoding='utf-8') as archivo:
    # Omitir los encabezados leyendo la primera línea antes del bucle
    encabezados2 = next(archivo)
    # Leer cada línea subsiguiente
    for linea in archivo:
        # Agregar la línea (sin el salto de línea final) a la lista 'jobs'
        skills.append(linea.strip())

contenido_skills = [skill.split(';') for skill in skills]
encabezados_skills = ['Habilidades','Nivel_experiencia','id']
skills = [dict(zip(encabezados_skills, skill)) for skill in contenido_skills]
tabla_hash_skills = {skill['id']: skill for skill in skills}

jobs_dic = []
jobs_excluidos = []

lista_encabezados = encabezados.split(';')

for job in jobs:
    # Aplica el reemplazo para manejar el ';' dentro de las URLs antes de dividir el trabajo en elementos
    patron = r'"([^"]*http[s]?://[^;]+); ([^"]+)"'
    reemplazo = lambda match: '"' + match.group(1) + ' or ' + match.group(2) + '"'
    job_modificado = re.sub(patron, reemplazo, job)

    # Convertir cada trabajo modificado en una lista para comparar longitudes
    lista_job = job_modificado.split(';')

    if len(lista_job) == len(lista_encabezados):
        # Si coinciden en longitud, se crea el diccionario de trabajos
        diccionario_trabajo = dict(zip(lista_encabezados, lista_job))

        # Convertir 'published_at' a un objeto datetime
        if 'published_at' in diccionario_trabajo:
            diccionario_trabajo['published_at'] = datetime.strptime(diccionario_trabajo['published_at'], "%Y-%m-%dT%H:%M:%S.%fZ")

        # Añadir al diccionario de trabajos a la lista jobs_dic
        jobs_dic.append(diccionario_trabajo)
    else:
        # Si no coinciden en longitud, ajusta según necesites. Aquí simplemente se agregan a jobs_excluidos.
        job_modificado2 = re.sub(r'"([^"]*);([^"]*)"', r'"\1, \2"', job)
        lista_job = job_modificado2.split(';')
        diccionario_trabajo = dict(zip(lista_encabezados, lista_job))
        if 'published_at' in diccionario_trabajo:
            diccionario_trabajo['published_at'] = datetime.strptime(diccionario_trabajo['published_at'], "%Y-%m-%dT%H:%M:%S.%fZ")
        jobs_excluidos.append(diccionario_trabajo)

jobs_complete = jobs_dic + jobs_excluidos

len(jobs_complete)
jobs_complete = sorted(jobs_complete, key=lambda x: x['published_at'])

primeras3 = jobs_complete[:3]
ultimas3 = jobs_complete[-3:]

formato_fecha_legible = "%Y-%m-%d %H:%M:%S"

print("Primeras tres ofertas de trabajo publicadas:")
for oferta in primeras3:
    fecha_legible = oferta['published_at'].strftime(formato_fecha_legible)
    print(f"{oferta['title']} - Publicado el: {fecha_legible} - Por la empresa: {oferta['company_name']} - Se requería un perfil: {oferta['experience_level']} - Para la ciudad de: {oferta['city']},{oferta['country_code']}")

print("\nÚltimas tres ofertas de trabajo publicadas:")
for oferta in ultimas3:
    fecha_legible = oferta['published_at'].strftime(formato_fecha_legible)
    print(f"{oferta['title']} - Publicado el: {fecha_legible} - Por la empresa: {oferta['company_name']} - Se requería un perfil: {oferta['experience_level']} - Para la ciudad de: {oferta['city']},{oferta['country_code']}")

tabla_hash = {diccionario['id']: diccionario for diccionario in jobs_complete}

"""# Requerimiento No. 1: Listar las últimas N ofertas de trabajo según su país y nivel de experticia"""

paises_unicos = set(oferta['country_code'] for oferta in tabla_hash.values())

list(paises_unicos)

def informe_req1(ofertas,num_ofertas, codigo_pais,nivel_experiencia):
  #validacion --------
  if codigo_pais not in paises_unicos:
        print("No hay ofertas laborales registradas para ese país.")
        return

  if nivel_experiencia not in ['junior','mid','senior']:
        print("No hay ofertas laborales registradas para ese nivel de experiencia.")
        return

  # desarrollo
  ofertas_filtradas = [oferta for oferta in ofertas.values()
  if oferta['country_code'] == codigo_pais and oferta['experience_level'] == nivel_experiencia
                       ]
  ofertas_filtradas = sorted(ofertas_filtradas, key=lambda x: x['published_at'], reverse=True)

  # total de ofertas de trabajo segun la condicion nivel de experiencia

  conteo = 0
  for oferta in ofertas.values():
    if oferta.get('experience_level') == nivel_experiencia:
      conteo += 1
     # return conteo

  #resultados ---------

  ultimas_n_ofertas = ofertas_filtradas[:num_ofertas]
  t1 = tabulate(ultimas_n_ofertas, headers="keys", tablefmt="grid")
  return print(f"El total de ofertas de trabajo ofrecidas para {codigo_pais} son {len(ofertas_filtradas)}\nEn la tabla a continuacion se presentan las ultimas {num_ofertas} ofertas de trabajo para el nivel de experiencia {nivel_experiencia}, el total de oferts de trabajo ofrecidas para este nivel de expericnica fue un total de {conteo} \n {t1}")


informe_req1(ofertas = tabla_hash,num_ofertas = 10, codigo_pais = 'PL',nivel_experiencia = 'junior')

"""# Requerimiento No. 2: Clasificar los N países con mayor número de ofertas de trabajo."""

def paises_con_mas_ofertas_laborales(ofertas_trabajo, n):
    conteo_paises = Counter(oferta['country_code'] for oferta in ofertas_trabajo.values())
    paises_mas_ofertas = conteo_paises.most_common(n)
    return paises_mas_ofertas

# Llamar a la función y mostrar resultados
n = 3  # Por ejemplo, para obtener los 3 países con más ofertas laborales
paises_mas_ofertas = paises_con_mas_ofertas_laborales(tabla_hash, n)

paises_mas_ofertas

# Iterar sobre cada oferta de trabajo en la tabla hash
#for oferta in tabla_hash.values():
    #pais = oferta['country_code']
    #if pais in conteo_ofertas_por_pais:
        # Si el país ya está en el diccionario, incrementa el conteo
        #conteo_ofertas_por_pais[pais] += 1
    #else:
        # Si no, inicializa el conteo para este país
        #conteo_ofertas_por_pais[pais] = 1

# Imprimir el conteo de ofertas por país
#print("Conteo de ofertas de trabajo por país:")
#for pais, conteo in conteo_ofertas_por_pais.items():
    #print(f"{pais}: {conteo} ofertas")

#for job_id, job_info in tabla_hash.items():
#  if job_id in tabla_hash_skills:
#    job_info.update(tabla_hash_skills[job_id])




def informe_req2(ofertas,num_paises, anio, mes):

  #validacion --------
  if anio not in [2022, 2023]:
    print("No hay ofertas laborales para la fecha que desea consultar.")
    return

    # Verificar si el mes está fuera del rango permitido
  if mes < 1 or mes > 12:
    print("No hay ofertas laborales para la fecha que desea consultar.")
    return

  #Desarrollo --------


  ofertas = [
    oferta for oferta in ofertas.values()
    if (oferta['published_at'].year == y1 and oferta['published_at'].month == m1)
    ]



  conteo_ofertas_por_pais = {}

# Iterar sobre cada oferta de trabajo en la tabla hash
  for oferta in ofertas:
    pais = oferta['country_code']
    if pais in conteo_ofertas_por_pais:
      conteo_ofertas_por_pais[pais] += 1
    else:
      conteo_ofertas_por_pais[pais] = 1

  ofertasPorPais = sorted(conteo_ofertas_por_pais.items(), key = lambda x: x[1], reverse= True)[:num_paises]

  ## numero de ciudades con mayr cantidad de ofertas

  ofertas_por_ciudad_pais = {}

  for oferta in ofertas:
    pais = oferta['country_code']
    ciudad = oferta['city']

    # Inicializar el país si aún no está en el diccionario
    if pais not in ofertas_por_ciudad_pais:
        ofertas_por_ciudad_pais[pais] = {}

    # Contar la oferta para la ciudad correspondiente
    if ciudad in ofertas_por_ciudad_pais[pais]:
        ofertas_por_ciudad_pais[pais][ciudad] += 1
    else:
        ofertas_por_ciudad_pais[pais][ciudad] = 1

  ciudad_max_ofertas_por_pais = {}

  for pais, ciudades in ofertas_por_ciudad_pais.items():
    # Encontrar la ciudad con el mayor número de ofertas en este país
    ciudad_max = max(ciudades, key=ciudades.get)
    ciudad_max_ofertas_por_pais[pais] = (ciudad_max, ciudades[ciudad_max])

  lista_ciudades_max_ofertas = [(pais, ciudad, conteo) for pais, (ciudad, conteo) in ciudad_max_ofertas_por_pais.items()]

  z = sorted(lista_ciudades_max_ofertas, key=lambda x: x[2], reverse=True)[:10]

  # conteos ---

  from collections import defaultdict, Counter

  agrupacion = defaultdict(lambda: defaultdict(lambda: {
    'habilidades': Counter(),
    'empresas': Counter(),
    'niveles_experiencia': [],
   }))

  # Llenando la estructura de datos agrupada
  for oferta in ofertas:
    pais = oferta['country_code']
    nivel = oferta['experience_level']
    habilidades = oferta.get('Habilidades', "").split(';')
    empresa = oferta['company_name']
    nivel_experiencia = int(oferta.get('Nivel_experiencia', 0))

    for habilidad in habilidades:
        agrupacion[pais][nivel]['habilidades'][habilidad.strip()] += 1
    agrupacion[pais][nivel]['empresas'][empresa] += 1
    agrupacion[pais][nivel]['niveles_experiencia'].append(nivel_experiencia)

  contador = 0

  # Procesando y presentando la información agrupada
  for pais, niveles in agrupacion.items():
    if contador >= num_paises:
      break
    for nivel, datos in niveles.items():
        if contador >=num_paises:
          break
        habilidades = datos['habilidades']
        empresas = datos['empresas']
        niveles_experiencia = datos['niveles_experiencia']

        habilidad_mas_solicitada, conteo_mas = habilidades.most_common(1)[0] if habilidades else ("Ninguna", 0)
        habilidad_menos_solicitada, conteo_menos = habilidades.most_common()[-1] if habilidades else ("Ninguna", 0)
        nivel_minimo_promedio = sum(niveles_experiencia) / len(niveles_experiencia) if niveles_experiencia else 0
        empresa_mas_ofertas, conteo_emp_mas = empresas.most_common(1)[0] if empresas else ("Ninguna", 0)
        empresa_menos_ofertas, conteo_emp_menos = empresas.most_common()[-1] if empresas else ("Ninguna", 0)
        num_empresas = len(empresas)

        print(f"Pais: {pais}, Nivel de experiencia: {nivel}")
        print(f"  Habilidades diferentes solicitadas: {len(habilidades)}")
        print(f"  Habilidad más solicitada: {habilidad_mas_solicitada}, veces: {conteo_mas}")
        print(f"  Habilidad menos solicitada: {habilidad_menos_solicitada}, veces: {conteo_menos}")
        print(f"  Nivel mínimo promedio de habilidades: {nivel_minimo_promedio:.2f}")
        print(f"  Número de empresas diferentes: {num_empresas}")
        print(f"  Empresa con mayor número de ofertas: {empresa_mas_ofertas}, ofertas: {conteo_emp_mas}")
        print(f"  Empresa con menor número de ofertas: {empresa_menos_ofertas}, ofertas: {conteo_emp_menos}")
        print("--------")

        contador += 1

  # Resultados ------

  t2 = tabulate(ofertasPorPais, headers=['Cod Pais', 'Num ofertas'], tablefmt="grid")
  t3 = tabulate(z, headers=['Cod Pais','Ciudad','Num Ofertas'], tablefmt="grid")

  return print(f"-El total de las ofertas de empleo registradas en el mes {mes} del año {anio} es {len(ofertas)}. \n-En la tabla acontinuacion se puede observar los {num_paises} paises con la mayor cantidad de ofertas laborales para el mes seleccionado \n{t2}\n- Ciudades con la mayor cantidad de ofertas laborales \n{t3} ")

informe_req2(ofertas = tabla_hash,num_paises = 10, anio = 2022, mes = 10)
